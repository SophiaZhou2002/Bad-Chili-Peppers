#pragma once

// internal
#include "common.hpp"

// stlib
#include <vector>
#include <random>
#include <iomanip>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>

#include "ai_system.hpp"
#include "fire_system.hpp"
#include "render_system.hpp"
#include "start_screen.hpp"
#include "tutorial_screen.hpp"
#include "settings_screen.hpp"
#include "level_select_screen.hpp"
#include "map_generator.hpp"
#include "popup_window.hpp"
#include "story_screen.hpp"
#include "end_screen.hpp"

// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:
	WorldSystem();

	// creates main window
	GLFWwindow* create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	// starts the game
	void init(MapGenerator* map_generator, PopupWindow& popup_window);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms);

	// check for collisions generated by the physics system
	void handle_collisions();

    // Handle what to do for each button
    void handle_button(BUTTON_ID button_id);

	// should the game be over ?
	bool is_over() const;

	// Get game state
	static GameState& get_game_state();
	
	static bool is_player_ingredient_collision(Entity player_entity, Entity ingredient_entity);
	static bool is_player_incorrect_ingredient_collision(Entity player_entity, Entity ingredient_entity);
	static bool is_player_enemy_collision(Entity player_entity, Entity enemy_entity);

    void load_level(LEVEL_ASSET_ID level_id);

private:

	float mouse_pos_x = 0.0f;
	float mouse_pos_y = 0.0f;
    bool is_space_pressed_on_playing = false;

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);

	// anim function for enemy bounce
	// @param is entity (enemy) and float elapsed ms
	// void return
	void updateEnemyBounceAnimation(Entity entity, float elapsed_ms);

	// anim function for enemy tornado
	// @param is entity (enemy) and float elapsed ms
	// void return
	void updateEnemyTornadoAnimation(Entity entity, float elapsed_ms);


	// anim function for player
	//@ param is entity(player) and float elapsed ms
	// void return
	void updatePlayerAnimation(Entity entity, float elapsed_ms);

	// for ingredient spawning
	// havent finished
	vec2 findRandomUnoccupiedPosition();

	
	// step helpers
	void update_window_title(float elapsed_ms);
	void remove_debug_entities();
	void remove_out_of_bounds_entities();


	void check_level_complete();
	void check_level_timeout();
	void check_level_death();
	
	void handle_level_complete(float elapsed_ms);
	void handle_level_timeout(float elapsed_ms);
	void handle_level_death(float elapsed_ms);

	/*
	* Updates the HUD for the ingredients
	*/
	void update_hud_ingredients();
	
	/* 
	* Updates the stage of the game depending on the current game state
	* @return true if the stage is complete, false otherwise
	*/
	bool update_stage();

	/*
	* Updates the in-game HUD
	* @param elapsed_ms: time since last update in milliseconds
	*/
	void update_hud(float elapsed_ms);
	
	/*
	* Updates the animation states of all entities with `AnimationState` component
	* @param elapsed_ms: time since last update in milliseconds
	*/
	void update_animation_states(float elapsed_ms);
	
	/*
	* Handles player power-up interactions
	* @param elapsed_ms: time since last update in milliseconds
	* @return number of active powerups
	*/
	int handle_powerups(float elapsed_ms);

	/*
	* Handles ingredient burning interactions
	* @param Entity entity
	* @return void
	*/
	void handle_ingredients_burning(float elapsed_ms);

	bool check_ingredients_collected();

	
	/* 
	* Handles player movement
	* @param elapsed_ms_since_last_update: time since last update in milliseconds
	* @return true if player is moving, false otherwise
	*/
	bool handle_player_movement(float elapsed_ms_since_last_update);
	
	/*
	* Handles player movement with linear interpolation
	* @param elapsed_ms_since_last_update: time since last update in milliseconds
	* @param player_entity: the player entity
	* @return true if player is moving, false otherwise
	*/
	bool handle_player_movement_while_lerp(float elapsed_ms_since_last_update, Entity& player_entity);
	
	/*
	* Handles player movement while idle
	* @param elapsed_ms_since_last_update: time since last update in milliseconds
	* @param player_entity: the player entity
	* @return true if player is moving, false otherwise
	*/
	bool handle_player_movement_while_idle(float elapsed_ms_since_last_update, Entity& player_entity);

	//update background music based on game state
	void update_sounds(GAME_SCREEN game_screen);
	
	// restart level
	void restart_game();

	// OpenGL window handle
	GLFWwindow* window;

    // Set the hand cursors
    GLFWcursor* hand_cursor;
    GLFWcursor* arrow_cursor;

	//Music 
	Mix_Music* gameplay_music;
	Mix_Music* startscreen_music;
	Mix_Music* story_music;
	Mix_Music* current_music = nullptr;
	Mix_Chunk* win_sound;
	Mix_Chunk* powerup_sound;
	Mix_Chunk* menuclick_sound;
	Mix_Chunk* pickup_correct_sound;
	Mix_Chunk* pickup_wrong_sound;
	Mix_Chunk* game_start;
	Mix_Chunk* fire_sound;
	Mix_Chunk* game_over;
	bool music_muted = false;

	// Initial game screen
	GAME_SCREEN game_screen = GAME_SCREEN::START;

	std::optional<Entity> timerText;
	std::optional<Entity> fpsText;
	bool fpsTextVisible;
	float fpsTimerUpdate;

	// Start screen
	StartScreen start_screen;
	TutorialScreen tutorial_screen;
	SettingsScreen settings_screen;
	LevelSelectScreen level_select_screen;
	StoryScreen story_screen;
	EndScreen end_screen;

    // Popup screens
    PopupWindow popup_window;

	// Game state
	MapGenerator* map_generator;
	float current_speed;

	// grid
	std::vector<Entity> grid_lines;

	
};